const fs = require('fs-extra');
const path = require('path');
const klawSync = require('klaw-sync');

/*
  See http://js.cytoscape.org/  for further explantion and possibilities about CytoScape
  Stéphane Bascher
  avatar.home.automation@gmail.com
  For Avatar
*/


/*
 * Create an instance of Graph
 * @class Graph
 * @param {Object}  CY      An instance of Cytoscape.js corresponds to the graph
 * @param {String} folder   Plugin folder (needed to get path of images and elements)
 * @returns {Object}
 */
var Graph = function Graph (CY, folder, conf) {
  this.CY = CY;
  this.pluginPath = folder;
  this.Config = conf;
}


/*
 * Get Graph instance
 * @param {none}
 * @returns {Object} Graph instance
 */
Graph.prototype.getGraph = function() {
    return new Promise((resolve, reject) => {
      this.CY ? resolve(this.CY) : reject ('Le graph n\'est pas initialisé')
    })
}


function random(min, max) {
 return Math.floor(Math.random() * (max - min + 1)) + min;
}

/*
 * Add element to Graph instance
 * @param {Object}    Graph instance
 * @param {String}    Id of the element
 * @returns {Object}  Element created
 */
Graph.prototype.addGraphElement = function(graph, id, layout, parent) {
  return new Promise((resolve, reject) => {
    id = id ? id : random(1, 100000).toString();
    graph.add({ group: "nodes",
                selector: (parent ? "node" : "node:parent"),
                layout: { name: (layout ? layout : null)},
                data: {
                  id: id,
                  parent: ((parent && typeof(parent) != "boolean") ? parent.id() : null)
                }
    });
    resolve(graph.getElementById(id));
  })
}


/*
 * Get element by ID
 * @param {String}    Id of the element
 * @returns {Object}  Element with Id
 */
Graph.prototype.getGraphElementByID = function(id) {
    return this.CY.$('#'+id);
}


/*
 * Get elements by Name and Class
 * @param {String}    Name of the element
 * @param {String}    Class of the element
 * @returns {Object}  Collection of all elements with same name and Class
 */
Graph.prototype.getGraphElementsByName = function(name, classe) {

  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    this.CY.nodes().forEach(function(ele) {
      if ((!classe && name == ele.data('name')) || (classe && name == ele.data('name') && ele.hasClass(classe)))
         collection = collection.union(ele);
    });
    resolve (collection);
  })
}


Graph.prototype.getGraphElementByName = function(name) {

  return new Promise((resolve, reject) => {
    let elem;
    this.CY.nodes().forEach(function(ele) {
      if (name == ele.data('name'))
         elem = ele;
    });
    resolve (elem);
  })
}



/*
 * Get elements by Class
 * @param {String}    Class of the element
 * @returns {Object}  Collection of elements with the Class
 */
Graph.prototype.getGraphElementsByClass = function(classe, id) {
  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    this.CY.nodes().forEach(function(ele) {
      if ((ele.hasClass(classe) && !id) || (ele.id() == id && ele.hasClass(classe)))
         collection = collection.union(ele);
    });
    resolve (collection);
  })
}


/*
 * Remove element by ID
 * @param {String}    ID of the element
 * @returns {none}
 */
Graph.prototype.removeGraphElementByID = function(id) {
  return new Promise((resolve, reject) => {
    this.CY.remove(this.CY.$('#'+id))
    resolve ();
  })
}


/*
 * Remove elements by Class
 * @param {String}    Class of elements
 * @returns {none}
 */
Graph.prototype.removeGraphElementsByClass = function(classe) {
  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    this.CY.nodes().forEach(function(ele) {
      if (ele.hasClass(classe))
         collection = collection.union(ele);
    });
    this.CY.remove(collection);
    resolve ();
  })
}


/*
 * Add class to the element
 * @param {Object}    Element
 * @param {String}    Class to add to the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementClass = function(elem, classe) {
  return new Promise((resolve, reject) => {
    elem.addClass(classe);
    resolve (elem);
  })
}


/*
 * Add image to the element
 * @param {Object}    Element
 * @param {String}    Full path image to add to the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementImage = function(elem, img) {
  return new Promise((resolve, reject) => {
    if (!img) return resolve (elem);
    if (!fs.existsSync(img)) return reject('Le fichier image '+img+' n\'existe pas');
    elem.style({
        'background-image': "url('"+img+"')"
    });
    resolve (elem);
  })
}


/*
 * Add rendering position to the element
 * @param {Object}    Element
 * @param {Integer}   X Position
 * @param {Integer}   Y Position
 * @returns {Object}  Element
 */
Graph.prototype.addElementRenderedPosition = function(elem, pos) {
  return new Promise((resolve, reject) => {
    if (!pos) return resolve (elem);

    elem.renderedPosition('x', pos.x);
    elem.renderedPosition('y', pos.y);
    resolve (elem);
  })
}


Graph.prototype.addElementRelativePosition = function(elem, pos) {
  return new Promise((resolve, reject) => {
    if (!pos) return resolve (elem);

    elem.relativePosition('x', pos.x);
    elem.relativePosition('y', pos.y);
    resolve (elem);
  })
}


Graph.prototype.addElementPosition = function(elem, pos) {
  return new Promise((resolve, reject) => {
    if (!pos) return resolve (elem);
    elem.position('x', pos.x);
    elem.position('y', pos.y);
    resolve (elem);
  })
}


/*
 * Add Name to the element
 * @param {Object}    Element
 * @param {String}    Name of the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementName = function(elem, data) {
  return new Promise((resolve, reject) => {
    if (!elem) return resolve ();
    if (!data) return resolve (elem);
    elem.data('name', data);
    resolve (elem);
  })
}



Graph.prototype.addElementLabelOnly = function(elem, label) {
  return new Promise((resolve, reject) => {
    if (!elem) return resolve ();
    if (!label) return resolve (elem);
    elem.style({
        'label': label
    });
    resolve (elem);
  })
}



Graph.prototype.addElementLabel = function(elem, label) {
  return new Promise((resolve, reject) => {
    if (!elem) return resolve ();
    if (!label) return resolve (elem);
    elem.style({
        'label': label.text,
        'text-valign': label.valign ? label.valign : 'center',
        'text-halign': label.halign ? label.halign : 'center',
        'font-size': label.fontSize ? label.fontSize :  "14px",
        'color': label.fontColor ? label.fontColor : "white",
        'text-outline-width': label.fontOutline ? label.fontOutline : 0,
        'text-rotation': label.textRotation ? label.textRotation : 0,
        'text-wrap': label['text-wrap'] ? label['text-wrap'] : "none",
        'text-max-width': label['text-max-width'] ? label['text-max-width'] : "100px",
        'text-justification': label['text-justification'] ? label['text-justification'] : "center"
    });
    resolve (elem);
  })
}


Graph.prototype.changeShape = function(elem, style) {
  return new Promise((resolve, reject) => {
    elem.style({
      'shape': style
    })
    resolve (elem);
  })
}


Graph.prototype.testElementStyle = function(elem, style, parent) {
  return new Promise((resolve, reject) => {
    elem.style({
        'background-opacity': (parent ? 0 : style.opacity),
        'selection-box-color': style.color,
        'background-color': style.color,
        'text-border-color': style.color,
        'text-outline-color': style.color,
        'text-background-color': style.color,
        'padding' : style.padding,
        'font-size': style.fontSize,
        'color': style.textColor
    });
    resolve (elem);
  })
}


Graph.prototype.addElementStyle = function(elem, style, parent) {
  return new Promise((resolve, reject) => {
    // "rgba(107, 101, 99, 1)",
    if (!style) return resolve (elem);
    elem.style({
        'shape': style.style,
        'border-width': 0,
        'text-border-width' : 0,
        'background-fit': 'cover',
        'background-opacity': (parent ? 0 : style.opacity),
        'text-opacity': 1,
        'text-outline-opacity' : 0,
        'text-background-opacity': 0,
        'text-border-opacity': 0,
        'border-opacity': 0,
        'selection-box-color': style.color,
        'background-color': style.color,
        'text-border-color': style.color,
        'text-outline-color': style.color,
        'text-background-color': style.color,
        'selection-box-border-width' : 0,
        'selection-box-opacity': 0,
        'padding' : style.padding
    });
    resolve (elem);
  })
}


/*
 * Add size to the element
 * @param {Object}    Element
 * @param {Integer}   size of the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementSize = function(elem, size) {
  return new Promise((resolve, reject) => {
    if (!size) return resolve (elem);
    if (!size.height) size.height = size.width;
    elem.style({
      'height': size.height,
      'width': size.width
    });
    resolve (elem);
  })
}


/*
 * Add border to the element
 * @param {Object}    Element
 * @param {String}    Optional - Color, default "white", can be rgba, direct string color, HEX code
 * @param {Integer}   Optional - Size of the border, default 6
 * @param {Integer}   Optional - Opacity of the border, default 0
 * @returns {Object}  Element
 */
Graph.prototype.addElementBorder = function(elem, color, width, opacity) {
  return new Promise((resolve, reject) => {
    elem.style({
      'border-color': color ? color : "white",
      'border-width': width ? width : 6,
      'border-opacity': opacity ? opacity : 0,
    });
    resolve (elem);
  })
}


/*
 * Add text font to the element
 * @param {Object}    Element
 * @param {Object}    Font description. See the function to know all possible params
                      Is is not mandatory to specify all params. Only what you want.
 * @returns {Object}  Element
 */
Graph.prototype.addElementFont = function(elem, options) {
  return new Promise((resolve, reject) => {
    let style = {};
    if (options['font-family']) style['font-family'] = options['font-family'];
    if (options['font-size']) style['font-size'] = options['font-size'];
    if (options['color']) style['color'] = options['color'];
    if (options['text-wrap']) style['text-wrap'] = options['text-wrap'];
    if (options['text-valign']) style['text-valign'] = options['text-valign'];
    if (options['text-halign']) style['text-halign'] = options['text-halign'];
    if (options['text-margin-x']) style['text-margin-x'] = options['text-margin-x'];
    if (options['text-margin-y']) style['text-margin-y'] = options['text-margin-y'];
    if (options['text-outline-width']) style['text-outline-width'] = options['text-outline-width'];
    if (options['text-outline-color']) style['text-outline-color'] = options['text-outline-color'];
    if (options['text-opacity']) style['text-opacity'] = options['text-opacity'];

    elem.style(style);
    resolve (elem);
  })
}



Graph.prototype.addElementData = function(elem, name, value) {
  return new Promise((resolve, reject) => {
    elem.data(name, value);
    resolve (elem);
  })
}


/*
 * Set/Unset the selection of the element
 * @param {Object}    Element
 * @param {Boolean}   Optional - selection, default false
 * @returns {Object}  Element
 */
Graph.prototype.selectElement = function(elem, selected) {
  return new Promise((resolve, reject) => {
    if (selected) {
      elem.data('selected', true);
      elem.style ({'border-opacity': 1});
    } else {
      elem.data('selected', false);
      elem.style ({'border-opacity': 0});
    }
    resolve (elem);
  })
}


/*
 * Lock/Unlock position of the element
 * @param {Object}    Element
 * @param {Boolean}   Optional - lock, default false
 * @returns {Object}  Element
 */
Graph.prototype.lockElement = function(elem, locked) {
  return new Promise((resolve, reject) => {
    if (locked)
      elem.lock();
    else
      elem.unlock();
    resolve (elem);
  })
}


Graph.prototype.grabbableElement = function(elem, grabb) {
  return new Promise((resolve, reject) => {
    if (!grabb)
      elem.ungrabify();
    else
      elem.grabify();
    resolve (elem);
  })
}


/*
 * Get if the element is locked
 * @param {Object}    Element
 * @returns {Boolean} true if the element is locked, false otherwize
 */
Graph.prototype.isElementLocked = function(elem) {
  return elem.locked();
}


/*
 * Get if the element is selected
 * @param {Object}    Element
 * @returns {Boolean} true if the element is selected, false otherwize
 */
Graph.prototype.isElementSelected = function(elem) {
  return elem.data('selected');
}


/*
 * Event Click for the element
 * @param {Object}    Element
 * @param {function}  The function to execute on click...
 * @returns {Object}  Element
 */
Graph.prototype.onClick = function(elem, callback) {
  return new Promise((resolve, reject) => {
    elem.on('tap', function(evt){
      callback(elem);
    });
    resolve (elem);
  })
}


/*
 * Event Right Click for the element
 * @param {Object}    Element
 * @param {function}  The function to execute on rigth click...
 * @returns {Object}  Element
 */
Graph.prototype.onRightClick = function(elem, callback) {
  return new Promise((resolve, reject) => {
    elem.on('cxttap', function(evt){
      callback(elem);
    });
    resolve (elem);
  })
}


Graph.prototype.onRightEnd = function(elem, callback) {
  return new Promise((resolve, reject) => {
    elem.on('cxttapend ', function(evt){
      callback(elem);
    });
    resolve (elem);
  })
}


/*
 * Load elements by saved JSon files in the assets/nodes folder
 * @param {none}
 * @returns {Object}  Collection of all elements loaded
 */
Graph.prototype.loadAllGraphElements = function() {

  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    if (fs.existsSync(this.pluginPath+'/assets/nodes')) {
      let nodes = klawSync(path.normalize (this.pluginPath+'/assets/nodes'), {nodir: true, depthLimit: 1});
      for (let i=0; i < nodes.length; i++) {
        let nodeJson = fs.readJsonSync (nodes[i].path, { throws: false });
        this.addGraphElement(this.CY, nodeJson.id)
        .then(elem => {
          return new Promise((resolve, reject) => {
            collection = collection.union(elem);
            resolve(elem);
          })
        })
        .then(elem =>   this.addElementClass(elem, nodeJson.classes))
        .then(elem => this.addElementName(elem, (nodeJson.name ? nodeJson.name : null)))
        .then(elem => this.addElementPosition(elem, {x: nodeJson.position.x, y: nodeJson.position.y}))
        .then(elem => {
          return new Promise((resolve, reject) => {
            elem.style(nodeJson.style);
            resolve(elem);
          })
        })
        .then(elem => this.selectElement(elem, nodeJson.selected))
        .then(elem => this.lockElement(elem, nodeJson.locked))
        .then(elem => {
          if ((i+1) == nodes.length)
            resolve (collection);
        })
        .catch (err => {
          console.log('err', err);
          resolve ();
        })
      }

      if (nodes.length == 0) resolve (collection);
    } else {
      resolve (collection);
    }
  });

}


/*
 * Save elements to JSon files in the assets/nodes folder
 * @param {String}    Class of elements to save as Json files
 * @returns {none}
 */
Graph.prototype.saveAllGraphElements = function(classe) {
  return new Promise((resolve, reject) => {
    this.CY.nodes().forEach((ele) => {
      if (classe && ele.hasClass(classe)) {
        let style = {};
        style.id = ele.id();
        if (ele.data('name')) style.name = ele.data('name');
        style.classes = ele.classes();
        style.selected = (ele.data('selected')) ? ele.data('selected') : false;
        style.locked  = ele.locked();
        style.position = {};
        style.position.x = ele.position('x');
        style.position.y = ele.position('y');
        style.style = {};
        if (ele._private.style['background-image'])
          style.style["background-image"] = path.normalize(ele._private.style['background-image'].strValue);
        style.style.height = ele.height();
        style.style.width =  ele.width();
        if (ele._private.style['border-color'])
          style.style['border-color'] = ele._private.style['border-color'].strValue;
        if (ele._private.style['border-width'])
          style.style['border-width'] = ele._private.style['border-width'].value;
        if (ele._private.style['border-opacity'])
          style.style['border-opacity'] = ele._private.style['border-opacity'].value;
        if (ele._private.style['font-family'])
          style.style['font-family'] = ele._private.style['font-family'].strValue;
        if (ele._private.style['font-size'])
          style.style['font-size'] = ele._private.style['font-size'].strValue;
        if (ele._private.style['color'])
          style.style['color'] = ele._private.style['color'].strValue;
        if (ele._private.style['text-wrap'])
          style.style['text-wrap'] = ele._private.style['text-wrap'].value;
        if (ele._private.style['text-valign'])
          style.style['text-valign'] = ele._private.style['text-valign'].value;
        if (ele._private.style['text-halign'])
          style.style['text-halign'] = ele._private.style['text-halign'].value;
        if (ele._private.style['text-margin-x'])
          style.style['text-margin-x'] = ele._private.style['text-margin-x'].strValue;
        if (ele._private.style['text-margin-y'])
          style.style['text-margin-y'] = ele._private.style['text-margin-y'].strValue;
        if (ele._private.style['text-outline-width'])
          style.style['text-outline-width'] = ele._private.style['text-outline-width'].value;
        if (ele._private.style['text-outline-color'])
          style.style['text-outline-color'] = ele._private.style['text-outline-color'].strValue;
        if (ele._private.style['text-opacity'])
          style.style['text-opacity'] = ele._private.style['text-opacity'].value;

        let folder = path.normalize (this.pluginPath+'/assets/nodes');
        fs.ensureDirSync(folder);
        fs.writeJsonSync(folder+'/'+style.id+'.json', style);
      }
    });

    resolve ();
  })
}


/*
 *  Export Graph
 */
module.exports.Graph = Graph;
